<?php

namespace Tests\Feature\Services;

use App\Events\Lead\LeadClosedSequence;
use App\Exceptions\Sequence\ActiveSequenceExistsException;
use App\Exceptions\Sequence\DuplicateSequenceAssignmentException;
use App\Exceptions\Sequence\MissingAssignedSequenceException;
use App\Exceptions\Sequence\NextSequenceActionUnavailableException;
use App\Exceptions\Sequence\SequenceHasNoEligibleSequenceActionsException;
use App\Models\Pivot\LeadSequence;
use App\Models\Sequence\SequenceAction;
use App\Models\Task\Task;
use Tests\TestCase;
use App\Models\Lead\Lead;
use App\Models\Sequence\Sequence;
use Database\Seeders\SequenceSeeder;
use App\Services\LeadSequenceService;
use App\Events\Lead\LeadAssignedSequence;
use Illuminate\Foundation\Testing\RefreshDatabase;

class LeadSequenceServiceTest extends TestCase
{
    use RefreshDatabase;

    protected LeadSequenceService $service;

    public function setUp(): void {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->service = app(LeadSequenceService::class);
    }

    /*****************************************************************************
     * Lead Sequence Assignment
     ****************************************************************************/

    public function test_assigning_a_sequence() {
        $this->seed([
            SequenceSeeder::class
        ]);

        /** @var Sequence $sequence */
        $sequence = Sequence::query()->first();

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $this->expectsEvents(LeadAssignedSequence::class);
        $this->service->assignSequence($sequence, $lead);
        $this->assertDatabaseHas('lead_sequence', [
            'lead_id' => $lead->id,
            'sequence_id' => $sequence->id,
            'sequence_action_id' => null,
            'closed_at' => null,
        ]);
    }

    public function test_that_we_prevent_assigning_multiple_active_sequences_for_a_lead() {
        $this->seed([
            SequenceSeeder::class,
            SequenceSeeder::class
        ]);

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $sequences = Sequence::take(2)->get();

        $this->service->assignSequence($sequences->first(), $lead);
        $this->expectException(ActiveSequenceExistsException::class);
        $this->service->assignSequence($sequences->last(), $lead);
    }

    public function test_that_we_cannot_assign_the_same_sequence_multiple_times() {
        $this->seed([
            SequenceSeeder::class,
        ]);

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $sequence = Sequence::first();

        $this->service->assignSequence($sequence, $lead);
        $this->service->endSequence($lead);
        $this->expectException(DuplicateSequenceAssignmentException::class);
        $this->service->assignSequence($sequence, $lead);
    }

    /*****************************************************************************
     * Lead Sequence Task Creation
     ****************************************************************************/
    public function test_creating_a_sequence_task() {
        $this->seed([
            SequenceSeeder::class
        ]);

        $sequence = Sequence::query()->first();
        /** @var SequenceAction $firstSequenceAction */
        $firstSequenceAction = $sequence->sequenceActions()->orderBy('ordinal_position')->first();

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $this->service->assignSequence($sequence, $lead);

        $task = $this->service->createNextTask($lead);
        $this->assertInstanceOf(Task::class, $task);
        $this->assertDatabaseHas('tasks', [
            'sequence_action_id' => $firstSequenceAction->id,
            'task_type_id' => $firstSequenceAction->task_type_id,
            'lead_id' => $lead->id,
            'instructions' => $firstSequenceAction->instructions
        ]);
    }

    public function test_missing_sequence_scenario_when_creating_new_task_for_lead()
    {
        $lead = Lead::factory()->create();
        $sequence = Sequence::factory()->create();

        $this->service->assignSequence($sequence, $lead);
        $this->service->endSequence($lead);

        $this->expectException(MissingAssignedSequenceException::class);
        $this->service->createNextTask($lead);
    }

    public function test_when_there_are_no_remaining_sequence_actions_for_sequence_assigned_to_lead()
    {
        $lead = Lead::factory()->create();
        $sequence = Sequence::factory()->create();

        $this->service->assignSequence($sequence, $lead);

        $this->expectException(NextSequenceActionUnavailableException::class);
        $this->service->createNextTask($lead);
    }

    /*****************************************************************************
     * Lead Sequence Assignment and First Task Creation
     ****************************************************************************/
    public function test_assigning_a_sequence_and_creating_first_task() {
        $this->seed([
            SequenceSeeder::class
        ]);

        $sequence = Sequence::query()->first();

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $this->service->assignSequenceToLeadAndCreateFirstTask($sequence, $lead);

        $firstSequenceAction = $sequence->sequenceActions()
            ->orderBy('ordinal_position', 'asc')
            ->first();

        $this->assertDatabaseHas('lead_sequence', [
            'lead_id' => $lead->id,
            'sequence_id' => $sequence->id,
            'sequence_action_id' => $firstSequenceAction->id,
            'closed_at' => null,
        ]);
    }

    public function test_when_sequence_is_assigned_and_has_no_workable_sequence_actions() {
        $sequence = Sequence::factory()->create();

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $this->expectException(SequenceHasNoEligibleSequenceActionsException::class);
        $this->service->assignSequenceToLeadAndCreateFirstTask($sequence, $lead);
    }


    /*****************************************************************************
     * Lead Sequence Ending
     ****************************************************************************/

    public function test_ending_a_sequence() {
        $sequence = Sequence::factory()->create();

        /** @var Lead $lead */
        $lead = Lead::factory()->create();

        $this->service->assignSequence($sequence, $lead);

        $this->expectsEvents(LeadClosedSequence::class);
        $this->service->endSequence($lead);

        $hasClosedSequenceRecently = LeadSequence::query()
            ->where('lead_id', $lead->id)
            ->where('sequence_id', $sequence->id)
            ->where('closed_at', '>', now()->subSeconds(3))
            ->exists();

        $this->assertTrue($hasClosedSequenceRecently);
    }
}
