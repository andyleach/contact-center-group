<?php

namespace Tests\Feature\Services;

use App\Events\Task\TaskAssigned;
use App\Events\Task\TaskAssignmentCancelled;
use App\Events\Task\TaskExpired;
use App\Events\Task\TaskRemoved;
use App\Exceptions\Task\TaskAssignmentException;
use App\Exceptions\Task\TaskInProcessException;
use App\Exceptions\Task\TaskRemovalException;
use App\Http\Services\TaskQueueService;
use App\Models\Agent\Agent;
use App\Models\Task\Task;
use App\Models\Task\TaskEvent;
use App\Models\Task\TaskEventReason;
use App\Models\Task\TaskEventType;
use App\Models\Task\TaskStatus;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class TaskQueueServiceTest extends TestCase
{
    use RefreshDatabase, WithFaker;

    /**
     * @var TaskQueueService $service
     */
    protected TaskQueueService $service;

    /**
     *
     */
    public function setUp(): void {
        parent::setUp(); // TODO: Change the autogenerated stub

        $this->service = new TaskQueueService();
    }

    /********************************************************
     * Task Cancellation
     *******************************************************/

    /**
     *
     */
    public function test_that_a_task_assignment_can_be_cancelled() {
        /** @var Agent $agent */
        $agent = Agent::factory()->create([]);

        /** @var Task $task */
        $task = Task::factory()->create([
            'task_status_id' => TaskStatus::ASSIGNED,
            'agent_id' => $agent->id,
            'assigned_at' => now()
        ]);

        $this->expectsEvents(TaskAssignmentCancelled::class);
        $task = $this->service->cancelTaskAssignment($task);
        $this->assertInstanceOf(Task::class, $task);

        $this->assertDatabaseHas(Task::class, [
            'task_status_id' => TaskStatus::PENDING,
            'agent_id' => null,
            'assigned_at' => null,
        ]);

        $this->assertDatabaseHas(TaskEvent::class, [
            'task_id' => $task->id,
            'task_event_type_id' => TaskEventType::TASK_ASSIGNMENT_CANCELLED,
            'task_event_reason_id' => TaskEventReason::NOT_APPLICABLE,
            'agent_id' => $agent->id,
        ]);
    }

    /**
     *
     */
    public function test_that_a_failure_to_cancel_task_assignment_throws_exception() {
        /** @var Task $task */
        $task = Task::factory()->create([
            'task_status_id' => TaskStatus::PENDING,
            'agent_id' => null,
            'assigned_at' => null
        ]);

        $this->expectException(TaskAssignmentException::class);
        $this->service->cancelTaskAssignment($task);
    }

    /********************************************************
     * Task Removal
     *******************************************************/


    /********************************************************
     * Task Assignment
     *******************************************************/
    /**
     *
     */
    public function test_a_task_can_be_assigned_to_a_user() {
        /** @var Agent $agent */
        $agent = Agent::factory()->create();

        // A task with a status of pending should update one row
        /** @var Task $task */
        $task = Task::factory()->create([
            'assigned_at' => now()->subSecond()
        ]);

        // The TaskAssigned event should be thrown
        $this->expectsEvents(TaskAssigned::class);
        // A user_id should be assigned to the task when assigned
        $task = $this->service->assignTaskToAgent($task, $agent);

        $this->assertInstanceOf(Task::class, $task, 'A task was not returned');

        // The assignment date should be set
        $this->assertNotNull($task->assigned_at, 'Assigned at is null');

        // The status should be set to "Task Assigned"
        $this->assertTrue(TaskStatus::ASSIGNED == $task->task_status_id);

        // A task event should be created
        $this->assertDatabaseHas(TaskEvent::class, [
            'task_event_type_id' => TaskEventType::TASK_ASSIGNED,
            'agent_id'            => $agent->id,
            'task_event_reason_id' => TaskEventReason::NOT_APPLICABLE,
            'task_id' => $task->id
        ]);
    }

    /**
     *
     */
    public function test_that_a_task_not_in_pending_status_cannot_be_assigned() {
        /** @var Agent $agent */
        $agent = Agent::factory()->create();

        /**
         * Create a task with a status that is not pending
         * @var Task $task
         */
        $task = Task::factory()->create([
            'task_status_id' => TaskStatus::DRAFT
        ]);

        $oldTask = $task->toArray();

        // Ensure that an exception is thrown
        $this->expectException(TaskAssignmentException::class);
        $this->doesntExpectEvents(TaskAssigned::class);
        $currentTask = $this->service->assignTaskToAgent($task, $agent);

        $this->assertEquals($oldTask, $currentTask->toArray());

        /// A task event should be created
        $this->assertDatabaseMissing(TaskEvent::class, [
            'task_event_type_id' => TaskEventType::TASK_ASSIGNED,
            'user_id'            => $agent->id,
            'task_event_reason_id' => TaskEventReason::NOT_APPLICABLE,
            'task_id' => $task->id
        ]);
    }

    /********************************************************
     * Task Expiration
     *******************************************************/
    /**
     *
     */
    public function test_that_a_task_that_has_passes_its_expiration_date_can_be_marked_as_expired() {
        /** @var Task $task */
        $task = Task::factory()->create([
            'task_status_id' => TaskStatus::PENDING,
            'expires_at' => now()->subSecond()
        ]);

        $this->expectsEvents(TaskExpired::class);
        $this->service->expire($task);

        $this->assertInstanceOf(Task::class, $task);

        $this->assertDatabaseHas(Task::class, [
            'task_status_id' => TaskStatus::EXPIRED,
            'agent_id' => null,
            'assigned_at' => null,
        ]);

        $this->assertDatabaseHas(TaskEvent::class, [
            'task_id' => $task->id,
            'task_event_type_id' => TaskEventType::TASK_EXPIRED,
            'task_event_reason_id' => TaskEventReason::NOT_APPLICABLE,
            'agent_id' => null,
        ]);
    }

    /**
     *
     */
    public function test_that_a_assigned_task_cannot_be_expired() {
        /** @var Task $task */
        $task = Task::factory()->create([
            'task_status_id' => TaskStatus::ASSIGNED,
            'expires_at' => now()->subSecond()
        ]);

        $this->expectException(TaskInProcessException::class);
        $this->service->expire($task);
    }
}


